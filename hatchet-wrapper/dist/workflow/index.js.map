{"version":3,"sources":["../../src/workflow/index.ts"],"sourcesContent":["import { Context, Workflow } from \"@hatchet-dev/typescript-sdk\";\nimport { DeepKeyOf, InputDefinition, InputSource, StepDefinition, StepInputs } from \"../_types\";\nexport type { DeepKeyOf, InputDefinition, InputSource, StepDefinition, StepInputs } from \"../_types\";\n\nimport z from \"zod\";\nimport { StepBuilder } from \"src/step\";\n\nexport class WorkflowBuilder<PreviousSteps extends Record<string, any> = {}, WorkflowInputSchema extends z.ZodTypeAny = z.ZodUnknown> {\n    private id: string;\n    private description: string;\n    private event?: string;\n    private steps: Array<{\n        name: string,\n        parents: string[],\n        run: (ctx: Context<any, any>) => Promise<any>\n    }> = [];\n    workflowInputSchema: WorkflowInputSchema;\n\n    constructor({ id, description, event, workflowInputSchema }: { id: string, description: string, event?: string, workflowInputSchema: WorkflowInputSchema }) {\n        this.id = id;\n        this.description = description;\n        this.event = event;\n        this.workflowInputSchema = workflowInputSchema;\n    }\n\n    addStep<T extends Record<string, InputDefinition<any>>, StepName extends string, R>(\n        stepName: StepName,\n        stepBuilder: StepBuilder<T, R>,\n        inputSources: { [K in keyof T]: InputSource<PreviousSteps, WorkflowInputSchema> }\n    ): WorkflowBuilder<PreviousSteps & Record<StepName, R>, WorkflowInputSchema> {\n        const step = stepBuilder.build();\n\n        const parents = Object.values(inputSources)\n            .filter((source): source is { type: 'stepOutput', stepName: keyof PreviousSteps & string, path: DeepKeyOf<PreviousSteps[keyof PreviousSteps & string]> } =>\n                source.type === 'stepOutput'\n            )\n            .map(source => source.stepName);\n\n        // Runtime check for valid parent step names\n        const invalidParents = parents.filter(parent => !this.steps.some(s => s.name === parent));\n        if (invalidParents.length > 0) {\n            throw new Error(`Invalid parent step(s): ${invalidParents.join(', ')}`);\n        }\n\n        this.steps.push({\n            name: stepName,\n            parents: [...new Set(parents)],\n            run: async (ctx: Context<any, any>) => {\n                const inputs: Record<string, any> = {};\n                for (const [inputName, source] of Object.entries(inputSources)) {\n                    let inputValue: unknown;\n                    if (source.type === 'workflowInput') {\n                        const workflowInput = this.workflowInputSchema.parse(ctx.workflowInput());\n                        inputValue = source.path.split('.').reduce((acc: any, part) => acc && acc[part], workflowInput);\n                    } else if (source.type === 'stepOutput') {\n                        const stepOutput = ctx.stepOutput(source.stepName as string);\n                        inputValue = source.path.split('.').reduce((acc: any, part) => acc && acc[part], stepOutput);\n                    }\n                    const inputDef = step.inputDefinitions[inputName];\n                    if (!inputDef) { throw new Error(`Input \"${inputName}\" not defined for step \"${stepName}\"`); }\n                    const schema = inputDef.schema;\n                    try {\n                        inputs[inputName] = schema.parse(inputValue);\n                    } catch (error) {\n                        if (error instanceof z.ZodError) {\n                            throw new Error(`Validation failed for step \"${stepName}\", input \"${inputName}\": ${error.errors.map(e => e.message).join(', ')}`);\n                        }\n                        throw error;\n                    }\n                }\n                return step.run(inputs as StepInputs<T>, ctx);\n            },\n        });\n        return this as WorkflowBuilder<PreviousSteps & Record<StepName, R>, WorkflowInputSchema>;\n    }\n\n    build(): Workflow {\n        return {\n            id: this.id,\n            description: this.description,\n            ...(this.event ? { on: { event: this.event } } : {}),\n            steps: this.steps,\n        };\n    }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA,iBAAc;AAGP,IAAM,kBAAN,MAA+H;AAAA,EAC1H;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAIH,CAAC;AAAA,EACN;AAAA,EAEA,YAAY,EAAE,IAAI,aAAa,OAAO,oBAAoB,GAAkG;AACxJ,SAAK,KAAK;AACV,SAAK,cAAc;AACnB,SAAK,QAAQ;AACb,SAAK,sBAAsB;AAAA,EAC/B;AAAA,EAEA,QACI,UACA,aACA,cACyE;AACzE,UAAM,OAAO,YAAY,MAAM;AAE/B,UAAM,UAAU,OAAO,OAAO,YAAY,EACrC;AAAA,MAAO,CAAC,WACL,OAAO,SAAS;AAAA,IACpB,EACC,IAAI,YAAU,OAAO,QAAQ;AAGlC,UAAM,iBAAiB,QAAQ,OAAO,YAAU,CAAC,KAAK,MAAM,KAAK,OAAK,EAAE,SAAS,MAAM,CAAC;AACxF,QAAI,eAAe,SAAS,GAAG;AAC3B,YAAM,IAAI,MAAM,2BAA2B,eAAe,KAAK,IAAI,CAAC,EAAE;AAAA,IAC1E;AAEA,SAAK,MAAM,KAAK;AAAA,MACZ,MAAM;AAAA,MACN,SAAS,CAAC,GAAG,IAAI,IAAI,OAAO,CAAC;AAAA,MAC7B,KAAK,OAAO,QAA2B;AACnC,cAAM,SAA8B,CAAC;AACrC,mBAAW,CAAC,WAAW,MAAM,KAAK,OAAO,QAAQ,YAAY,GAAG;AAC5D,cAAI;AACJ,cAAI,OAAO,SAAS,iBAAiB;AACjC,kBAAM,gBAAgB,KAAK,oBAAoB,MAAM,IAAI,cAAc,CAAC;AACxE,yBAAa,OAAO,KAAK,MAAM,GAAG,EAAE,OAAO,CAAC,KAAU,SAAS,OAAO,IAAI,IAAI,GAAG,aAAa;AAAA,UAClG,WAAW,OAAO,SAAS,cAAc;AACrC,kBAAM,aAAa,IAAI,WAAW,OAAO,QAAkB;AAC3D,yBAAa,OAAO,KAAK,MAAM,GAAG,EAAE,OAAO,CAAC,KAAU,SAAS,OAAO,IAAI,IAAI,GAAG,UAAU;AAAA,UAC/F;AACA,gBAAM,WAAW,KAAK,iBAAiB,SAAS;AAChD,cAAI,CAAC,UAAU;AAAE,kBAAM,IAAI,MAAM,UAAU,SAAS,2BAA2B,QAAQ,GAAG;AAAA,UAAG;AAC7F,gBAAM,SAAS,SAAS;AACxB,cAAI;AACA,mBAAO,SAAS,IAAI,OAAO,MAAM,UAAU;AAAA,UAC/C,SAAS,OAAO;AACZ,gBAAI,iBAAiB,WAAAA,QAAE,UAAU;AAC7B,oBAAM,IAAI,MAAM,+BAA+B,QAAQ,aAAa,SAAS,MAAM,MAAM,OAAO,IAAI,OAAK,EAAE,OAAO,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,YACpI;AACA,kBAAM;AAAA,UACV;AAAA,QACJ;AACA,eAAO,KAAK,IAAI,QAAyB,GAAG;AAAA,MAChD;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EAEA,QAAkB;AACd,WAAO;AAAA,MACH,IAAI,KAAK;AAAA,MACT,aAAa,KAAK;AAAA,MAClB,GAAI,KAAK,QAAQ,EAAE,IAAI,EAAE,OAAO,KAAK,MAAM,EAAE,IAAI,CAAC;AAAA,MAClD,OAAO,KAAK;AAAA,IAChB;AAAA,EACJ;AACJ;","names":["z"]}